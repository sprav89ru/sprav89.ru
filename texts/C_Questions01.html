<!DOCTYPE html>
<html>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>C++ Вопросы</title>
<style type="text/css">
textarea {
    width: 30%; /* Ширина поля в процентах */
    height: 200px; Высота поля в пикселах */
     /* resize: none; Запрещаем изменять размер */
   } 
 p {margin: 10px 0px 5px 1px;}  

.back_site {background:#B9CDF3} 
.back_xml {background:#ECF997} 
.back_php {background:#F6C3F8} 

</style>
<body>

<h1>C++ Вопросы</h1>

<h3>Параметры функции загрузки Формы: </h3>
<code>private: System::Void Form1_Load(System::Object^  sender, System::EventArgs^  e)</code>

<h3>Что означает -> например, в строке: <code>button1->Text = "Извлечь корень";</code> или в строке <code>textBox1->Clear();</code></h3>
<p><b>Оператор "стрелка" (->) позволяет получить доступ к членам структуры с помощью указателя.</b>(ниже)</p>

<h3>Что означает :: например, в строке:</h3>
<code>System::Globalization::NumberStyles::Number</code>

<h2>Шилдт, Герберт. C++ from the Ground Up Third Edition.fb2</h2>
<h3>Глава 10: Структуры и объединения</h3>
<p>В языке C++ определено несколько составных типов данных, т.е. типов, которые состоят из двух или более элементов.<br />
С одним из составных типов — <i>массивом</i> — вы уже знакомы.<br />
С двумя другими — <i>структурами и объединениями</i> — вы познакомитесь в этой главе, а знакомство с еще одним типом — <i>классом</i> — мы отложим до главы 11.</p>
<code>struct inv_type {<br />
　char item[40]; // наименование товара<br />
　double cost; // стоимость<br />
　double retail; // розничная цена<br />
　int on_hand; // имеющееся в наличии количество<br />
　int lead_time; // число дней до пополнения запасов<br />
};</code>
<p>...</p>
<code>inv_type inv_var;</code>
<p>Вот теперь объявляется структурная переменная типа inv_type с именем inv_var.<br />
Помните: определяя структуру, вы определяете новый тип данных, но он не будет реализован до тех пор, пока вы не объявите переменную того типа, который уже реально существует.</p>
<p>Доступ к члену структуры — через оператор "точка":</p>
<code>inv_var.cost = 10.39;</code>

<p>Указатель на структуру объявляется так же, как указатель на любую другую переменную, т.е. с помощью символа "*", поставленного перед именем структурной переменной.<br />
Например, используя определенную выше структуру inv_type, можно записать следующую инструкцию, которая объявляет переменную inv_pointer указателем на данные типа inv_type:</p>
<code>inv_type *inv_pointer;</code>
<p>Чтобы найти адрес структурной переменной, необходимо перед ее именем разместить оператор "&".</p>
<code>bal *p; // Объявляем указатель на структуру.</code>
<p>Тогда при выполнении инструкции</p>
<code>р = &person;</code>
<p>в указатель р будет помещен адрес структурной переменной person.</p>
<p>К членам структуры можно получить доступ с помощью указателя на эту структуру.</p>
<p>Но в этом случае используется не оператор "точка", а оператор "->".</p>
<p><b>Оператор "стрелка" (->) позволяет получить доступ к членам структуры с помощью указателя.</b></p>

<p>Указатель на структуру можно использовать в качестве параметра функции.</p>
<p>Важно помнить о таком способе передачи параметров, поскольку он работает гораздо быстрее, чем в случае, когда функции "собственной персоной" передается объемная структура.</p>
<p>(Передача указателя всегда происходит быстрее, чем передача самой структуры.)</p>
<p><b>Узелок на память.</b></p>
<p><b>Чтобы получить доступ к членам структуры, используйте оператор "точка".</b></p>
<p><b>Чтобы получить доступ к членам структуры с помощью указателя, используйте оператор "стрелка".</b></p>

<p></p>
<p></p>
<p></p>


</body>

</html>